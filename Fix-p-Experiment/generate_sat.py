# generate_sat.py

import random
import os

def generate_random_cnf(num_vars, num_clauses, clause_length=3, output_dir='sat_instances', filename=None):
    """
    Generates a random CNF SAT instance and writes it to a file in DIMACS format.

    :param num_vars: Number of variables in the SAT instance.
    :param num_clauses: Number of clauses in the SAT instance.
    :param clause_length: Number of literals per clause (k in k-CNF).
    :param output_dir: Directory to save the generated CNF files.
    :param filename: Optional filename. If None, a filename is autogenerated.
    :return: Path to the generated CNF file.
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    if filename is None:
        filename = f'random_k{clause_length}_v{num_vars}_c{num_clauses}.cnf'
    
    filepath = os.path.join(output_dir, filename)
    
    with open(filepath, 'w') as f:
        # Write the problem line
        f.write(f'p cnf {num_vars} {num_clauses}\n')
        
        for _ in range(num_clauses):
            clause = []
            for _ in range(clause_length):
                var = random.randint(1, num_vars)
                sign = random.choice([True, False])
                literal = var if sign else -var
                clause.append(str(literal))
            clause.append('0')  # Clause termination
            f.write(' '.join(clause) + '\n')
    
    print(f'Generated CNF file: {filepath}')
    return filepath

def generate_satisfiable_cnf(num_vars, num_clauses, clause_length=3, output_dir='sat_instances', filename=None):
    """
    Generates a satisfiable CNF SAT instance by first creating a random model and ensuring all clauses are satisfied.

    :param num_vars: Number of variables in the SAT instance.
    :param num_clauses: Number of clauses in the SAT instance.
    :param clause_length: Number of literals per clause.
    :param output_dir: Directory to save the generated CNF files.
    :param filename: Optional filename. If None, a filename is autogenerated.
    :return: Path to the generated CNF file and the satisfying assignment.
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    if filename is None:
        filename = f'sat_k{clause_length}_v{num_vars}_c{num_clauses}.cnf'
    
    filepath = os.path.join(output_dir, filename)
    
    # Generate a random model
    model = {var: random.choice([True, False]) for var in range(1, num_vars + 1)}
    
    with open(filepath, 'w') as f:
        # Write the problem line
        f.write(f'p cnf {num_vars} {num_clauses}\n')
        
        for _ in range(num_clauses):
            clause = []
            # Ensure the clause is satisfied by the model
            satisfied = False
            literals = []
            for _ in range(clause_length):
                var = random.randint(1, num_vars)
                sign = model[var] if random.random() > 0.5 else not model[var]
                literal = var if sign else -var
                literals.append(literal)
            # To ensure at least one literal is satisfied, randomly select one to align with the model
            if literals:
                idx = random.randint(0, clause_length - 1)
                literals[idx] = var if model[var] else -var
            clause = [str(lit) for lit in literals]
            clause.append('0')
            f.write(' '.join(clause) + '\n')
    
    print(f'Generated satisfiable CNF file: {filepath}')
    print(f'Satisfying assignment: {model}')
    return filepath, model

def generate_multiple_cnf(num_instances, num_vars_range, num_clauses_range, clause_length=3, satisfiable=True, output_dir='sat_instances'):
    """
    Generates multiple CNF SAT instances with varying numbers of variables and clauses.

    :param num_instances: Number of CNF files to generate.
    :param num_vars_range: Tuple (min_vars, max_vars) specifying the range of variables.
    :param num_clauses_range: Tuple (min_clauses, max_clauses) specifying the range of clauses.
    :param clause_length: Number of literals per clause.
    :param satisfiable: If True, generate satisfiable instances; otherwise, generate random instances.
    :param output_dir: Directory to save the generated CNF files.
    """
    for i in range(1, num_instances + 1):
        num_vars = random.randint(*num_vars_range)
        num_clauses = random.randint(*num_clauses_range)
        if satisfiable:
            filename = f'sat_instance_{i}_k{clause_length}_v{num_vars}_c{num_clauses}.cnf'
            generate_satisfiable_cnf(num_vars, num_clauses, clause_length, output_dir, filename)
        else:
            filename = f'random_instance_{i}_k{clause_length}_v{num_vars}_c{num_clauses}.cnf'
            generate_random_cnf(num_vars, num_clauses, clause_length, output_dir, filename)

def main():
    import argparse

    parser = argparse.ArgumentParser(description='Generate random SAT instances in DIMACS CNF format.')
    subparsers = parser.add_subparsers(dest='command', help='Sub-command help')

    # Sub-parser for generating a single random CNF
    parser_random = subparsers.add_parser('random', help='Generate a random CNF SAT instance.')
    parser_random.add_argument('--num_vars', type=int, required=True, help='Number of variables.')
    parser_random.add_argument('--num_clauses', type=int, required=True, help='Number of clauses.')
    parser_random.add_argument('--clause_length', type=int, default=3, help='Number of literals per clause.')
    parser_random.add_argument('--output_dir', type=str, default='sat_instances', help='Output directory.')
    parser_random.add_argument('--filename', type=str, default=None, help='Output filename.')

    # Sub-parser for generating a single satisfiable CNF
    parser_sat = subparsers.add_parser('satisfiable', help='Generate a satisfiable CNF SAT instance.')
    parser_sat.add_argument('--num_vars', type=int, required=True, help='Number of variables.')
    parser_sat.add_argument('--num_clauses', type=int, required=True, help='Number of clauses.')
    parser_sat.add_argument('--clause_length', type=int, default=3, help='Number of literals per clause.')
    parser_sat.add_argument('--output_dir', type=str, default='sat_instances', help='Output directory.')
    parser_sat.add_argument('--filename', type=str, default=None, help='Output filename.')

    # Sub-parser for generating multiple CNFs
    parser_multiple = subparsers.add_parser('multiple', help='Generate multiple CNF SAT instances.')
    parser_multiple.add_argument('--num_instances', type=int, required=True, help='Number of CNF instances to generate.')
    parser_multiple.add_argument('--num_vars_min', type=int, required=True, help='Minimum number of variables.')
    parser_multiple.add_argument('--num_vars_max', type=int, required=True, help='Maximum number of variables.')
    parser_multiple.add_argument('--num_clauses_min', type=int, required=True, help='Minimum number of clauses.')
    parser_multiple.add_argument('--num_clauses_max', type=int, required=True, help='Maximum number of clauses.')
    parser_multiple.add_argument('--clause_length', type=int, default=3, help='Number of literals per clause.')
    parser_multiple.add_argument('--satisfiable', action='store_true', help='Generate satisfiable instances.')
    parser_multiple.add_argument('--output_dir', type=str, default='sat_instances', help='Output directory.')

    args = parser.parse_args()

    if args.command == 'random':
        generate_random_cnf(
            num_vars=args.num_vars,
            num_clauses=args.num_clauses,
            clause_length=args.clause_length,
            output_dir=args.output_dir,
            filename=args.filename
        )
    elif args.command == 'satisfiable':
        generate_satisfiable_cnf(
            num_vars=args.num_vars,
            num_clauses=args.num_clauses,
            clause_length=args.clause_length,
            output_dir=args.output_dir,
            filename=args.filename
        )
    elif args.command == 'multiple':
        generate_multiple_cnf(
            num_instances=args.num_instances,
            num_vars_range=(args.num_vars_min, args.num_vars_max),
            num_clauses_range=(args.num_clauses_min, args.num_clauses_max),
            clause_length=args.clause_length,
            satisfiable=args.satisfiable,
            output_dir=args.output_dir
        )
    else:
        parser.print_help()

if __name__ == '__main__':
    main()
